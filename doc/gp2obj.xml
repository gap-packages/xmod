<!-- ------------------------------------------------------------------- -->
<!--                                                                     -->
<!--  gp2obj.xml            XMod documentation            Chris Wensley  -->
<!--                                                        & Murat Alp  -->
<!--  Copyright (C) 1996-2020, Chris Wensley et al,                      --> 
<!--  School of Computer Science, Bangor University, U.K.                --> 
<!--                                                                     -->
<!-- ------------------------------------------------------------------- -->

<?xml version="1.0" encoding="UTF-8"?>

<Chapter Label="chap-gp2obj">

<Heading>2d-groups : crossed modules and cat<M>^1</M>-groups</Heading>

<Index>2d-domain</Index>
<Index>2d-group</Index>
The term <E>2d-group</E> refers to a set of equivalent categories 
of which the most common are the categories of 
<E>crossed modules</E>; <E>cat<M>^1</M>-groups</E>; and <E>group-groupoids</E>, 
all of which involve a pair of groups. 

<Section Label="sect-constructions">
<Heading>Constructions for crossed modules</Heading>

<Index>crossed module</Index>
A crossed module (of groups)  <M>\calX = (\partial : S \to R )</M> 
consists of a group homomorphism <M>\partial </M>, 
called the <E>boundary</E> of <M>\calX</M>, 
with <E>source</E> <M>S</M>  and <E>range</E> <M>R</M>. 
The group <M>R</M> acts on itself by conjugation, 
and on <M>S</M> by an <E>action</E> 
<M>\alpha : R \to {\rm Aut}(S)</M> such that,  
for all <M>s,s_1,s_2 \in S</M>  and  <M>r \in R</M>,
<Display>
{\bf XMod\ 1}  :   \partial(s^r) 
   = r^{-1} (\partial s) r
   = (\partial s)^r,
\qquad
{\bf XMod\ 2}  :   s_1^{\partial s_2} 
   = s_2^{-1}s_1 s_2
   = {s_1}^{s_2}.
</Display> 
When only the first of these axioms is satisfied, the resulting structure is 
a <E>pre-crossed module</E> 
(see section <Ref Sect="sect-precrossed-modules" />).
The kernel of  <M>\partial</M>  is abelian.
<P/> 
(Much of the literature on crossed modules uses left actions, 
but we have chosen to use right actions in this package 
since that is the standard choice for group actions in &GAP;.) 

<ManSection>
   <Func Name="XMod"
         Arg="args" />
   <Oper Name="XModByBoundaryAndAction"
         Arg="bdy act" />
<Description>
The global function <C>XMod</C> calls one of the standard constructions
described in the following subsections. 
In the example the boundary is the identity mapping on <C>c5</C> 
and the action is trivial. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> c5 := Group( (5,6,7,8,9) );;
gap> SetName( c5, "c5" );
gap> id5 := IdentityMapping( c5 );;
gap> ac5 := AutomorphismGroup( c5 );; 
gap> act := MappingToOne( c5, ac5 );;
gap> XMod( id5, act ) = XModByBoundaryAndAction( id5, act );
true
]]>
</Example>

<ManSection>
   <Oper Name="XModByNormalSubgroup"
         Arg="G N" />
<Description>
A <E>conjugation crossed module</E> is the inclusion of a normal subgroup  
<M>S \unlhd R</M>, where <M>R</M> acts on <M>S</M> by conjugation.
</Description>
</ManSection>

<ManSection>
   <Oper Name="XModByTrivialAction"
         Arg="bdy" />
<Description>
A <E>trivial action crossed module</E>  <M>(\partial : S \to R)</M>
has  <M>s^r = s</M>  for all  <M>s \in S, \; r \in R</M>,  
the source is abelian and the image lies in the centre of the range.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> q8 := QuaternionGroup( IsPermGroup, 8 );
Group([ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ])
gap> SetName( q8, "q8" );
gap> c2 := Centre( q8 );                     
Group([ (1,3)(2,4)(5,7)(6,8) ])
gap> SetName( c2, "<-1>" );
gap> bdy := InclusionMappingGroups( q8, c2 );;
gap> X8a := XModByTrivialAction( bdy );
[<-1>->q8]
gap> c4 := Subgroup( q8, [q8.1] );;
gap> SetName( c4, "<i>" );
gap> X8b := XModByNormalSubgroup( q8, c4 );
[<i>->q8]
gap> Display(X8b);        
Crossed module [<i>->q8] :- 
: Source group has generators:
  [ (1,5,3,7)(2,8,4,6) ]
: Range group q8 has generators:
  [ (1,5,3,7)(2,8,4,6), (1,2,3,4)(5,6,7,8) ]
: Boundary homomorphism maps source generators to:
  [ (1,5,3,7)(2,8,4,6) ]
: Action homomorphism maps range generators to automorphisms:
  (1,5,3,7)(2,8,4,6) --> { source gens --> [ (1,5,3,7)(2,8,4,6) ] }
  (1,2,3,4)(5,6,7,8) --> { source gens --> [ (1,7,3,5)(2,6,4,8) ] }
  These 2 automorphisms generate the group of automorphisms.
]]>
</Example>

<ManSection>
   <Attr Name="XModByAutomorphismGroup"
         Arg="grp" />
   <Attr Name="XModByInnerAutomorphismGroup"
         Arg="grp" />
   <Oper Name="XModByGroupOfAutomorphisms"
         Arg="G A" />
<Description>
An <E>automorphism crossed module</E> has as range a subgroup <M>R</M>
of the automorphism group  Aut<M>(S)</M>  of  <M>S</M>
which contains the inner automorphism group of <M>S</M>.
The boundary maps <M>s \in S</M> to the inner automorphism of <M>S</M> 
by <M>s</M>.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> X5 := XModByAutomorphismGroup( c5 );
[c5 -> Aut(c5)] 
gap> Display( X5 );
Crossed module [c5->Aut(c5)] :- 
: Source group c5 has generators:
  [ (5,6,7,8,9) ]
: Range group Aut(c5) has generators:
  [ GroupHomomorphismByImages( c5, c5, [ (5,6,7,8,9) ], [ (5,7,9,6,8) ] ) ]
: Boundary homomorphism maps source generators to:
  [ IdentityMapping( c5 ) ]
: Action homomorphism maps range generators to automorphisms:
  GroupHomomorphismByImages( c5, c5, [ (5,6,7,8,9) ], 
[ (5,7,9,6,8) ] ) --> { source gens --> [ (5,7,9,6,8) ] }
  This automorphism generates the group of automorphisms.
]]>
</Example>

<ManSection>
   <Oper Name="XModByCentralExtension"
         Arg="bdy" />
<Description>
A <E>central extension crossed module</E> has as boundary a surjection
<M>\partial : S \to R</M>, with central kernel,
where <M>r \in R</M> acts on <M>S</M> by conjugation 
with <M>\partial^{-1}r</M>.
</Description>
</ManSection>
<Example>
<![CDATA[
gap> gen12 := [ (1,2,3,4,5,6), (2,6)(3,5) ];;
gap> d12 := Group( gen12 );;                  
gap> gen6 := [ (7,8,9), (8,9) ];;
gap> s3 := Group( gen6 );;
gap> SetName( d12, "d12" );  SetName( s3, "s3" ); 
gap> pr12 := GroupHomomorphismByImages( d12, s3, gen12, gen6 );;
gap> Kernel( pr12 ) = Centre( d12 );
true
gap> X12 := XModByCentralExtension( pr12 );;
gap> Display( X12 );                         
Crossed module [d12->s3] :- 
: Source group d12 has generators:
  [ (1,2,3,4,5,6), (2,6)(3,5) ]
: Range group s3 has generators:
  [ (7,8,9), (8,9) ]
: Boundary homomorphism maps source generators to:
  [ (7,8,9), (8,9) ]
: Action homomorphism maps range generators to automorphisms:
  (7,8,9) --> { source gens --> [ (1,2,3,4,5,6), (1,3)(4,6) ] }
  (8,9) --> { source gens --> [ (1,6,5,4,3,2), (2,6)(3,5) ] }
  These 2 automorphisms generate the group of automorphisms.
]]>
</Example>

<ManSection>
   <Oper Name="XModByPullback"
         Arg="xmod hom" />
<Description>
Let <M>\calX_0 = (\mu : M \to P)</M> be a crossed module. 
If <M>\nu : N \to P</M> is a group homomorphism with the same range 
as <M>\calX_0</M>, form the pullback group 
<M>L = M \times_P N</M>, 
with projection <M>\lambda : L \to N</M> 
(as defined in the <Package>Utils</Package> package). 
Then <M>N</M> acts on <M>L</M> by 
<M>(m,n)^{n'} := (m^{\nu n'},n^{n'})</M>, 
so that <M>\calX_1 = (\lambda : L \to N)</M> 
is the <E> pullback crossed module</E> 
determined by <M>\calX_0</M> and <M>\nu</M>. 
There is also a morphism of crossed modules 
<M>(\kappa,\nu) : \calX_1 \to \calX_2</M>. 
<P/>
The example forms a pullback of the crossed module <C>X12</C> 
of the previous subsection. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> gens4 := [ (11,12), (12,13), (13,14) ];; 
gap> s4 := Group( gens4 );; 
gap> theta := GroupHomomorphismByImages( s4, s3, gens4, [(7,8),(8,9),(7,8)] );;
gap> X1 := XModByPullback( X12, theta );; 
gap> StructureDescription( Source( X1 ) );
"C2 x S4"
gap> SetName( s4, "s4" );  SetName( Source( X1 ), "c2s4" ); 
gap> infoX1 := PullbackInfo( Source( X1 ) );;
gap> infoX1!.directProduct;
Group([ (1,2,3,4,5,6), (2,6)(3,5), (7,8), (8,9), (9,10) ])
gap> infoX1!.projections[1];
[ (7,8)(9,10), (7,9)(8,10), (2,6)(3,5)(8,9), (1,5,3)(2,6,4)(8,10,9), 
  (1,6,5,4,3,2)(8,9,10) ] -> [ (), (), (2,6)(3,5), (1,5,3)(2,6,4), 
  (1,6,5,4,3,2) ]
gap> infoX1!.projections[2];
[ (7,8)(9,10), (7,9)(8,10), (2,6)(3,5)(8,9), (1,5,3)(2,6,4)(8,10,9), 
  (1,6,5,4,3,2)(8,9,10) ] -> [ (11,12)(13,14), (11,13)(12,14), (12,13), 
  (12,14,13), (12,13,14) ]
]]>
</Example>

<ManSection>
   <Oper Name="XModByAbelianModule"
         Arg="abmod" />
<Description>
A <E>crossed abelian module</E> has an abelian module as source
and the zero map as boundary.
See section <Ref Sect="sect-abelian-modules" /> for an example. 
</Description>
</ManSection>

<ManSection>
   <Oper Name="DirectProduct"
         Arg="X1 X2" Label="for crossed modules" />
<Description>
The direct product  <M>\calX_{1} \times \calX_{2}</M>
of two crossed modules has source  <M>S_1 \times S_2</M>,
range  <M>R_1 \times R_2</M>  and boundary
<M>\partial_1 \times \partial_2</M>,  with  <M>R_1,\ R_2</M>  acting
trivially on  <M>S_2,\ S_1</M>  respectively. 
The embeddings and projections are constructed automatically, 
and placed in the <C>DirectProductInfo</C> attribute, 
together with the two <E>objects</E> <M>\calX_{1} \times \calX_{2}</M>. 
<P/> 
The example constructs the product of the two crossed modules formed in 
subsection <Ref Oper="XModByTrivialAction"/>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> X8ab := DirectProduct( X8a, X8b );
[[<-1>->q8]x[<i>->q8]]
gap> infoX8ab := DirectProductInfo( X8ab );
rec( 
  embeddings := [ [[<-1>->q8] => [<-1>x<i>->q8xq8]], 
      [[<i>->q8] => [<-1>x<i>->q8xq8]] ], objects := [ [<-1>->q8], [<i>->q8] ]
    , 
  projections := [ [[<-1>x<i>->q8xq8] => [<-1>->q8]], 
      [[<-1>x<i>->q8xq8] => [<i>->q8]] ] )
gap> DirectProduct( X8a, X8b, X12 );
[[[<-1>->q8]x[<i>->q8]]x[d12->s3]]
]]>
</Example>

<ManSection>
   <Attr Name="Source"
         Arg="X0" Label="for crossed modules" />
   <Attr Name="Range"
         Arg="X0" Label="for crossed modules" />
   <Attr Name="Boundary"
         Arg="X0" Label="for crossed modules" />
   <Attr Name="XModAction"
         Arg="X0" Label="for crossed modules of groups" />
<Description>
The following attributes are used in the construction of
a crossed module <C>X0</C>.
<List>
<Item>
<C>Source(X0)</C> and <C>Range(X0)</C> are the source <M>S</M> 
and range <M>R</M> of <M>\partial</M>, the boundary <C>Boundary(X0)</C>;
</Item>
<Item>
<C>XModAction(X0)</C> is a homomorphism from <M>R</M> 
to a group of automorphisms of <C>X0</C>.
</Item>
</List>
<Index>AutoGroup</Index> 
(Up until version 2.63 there was an additional attribute <C>AutoGroup</C>, 
the range of <C>XModAction(X0)</C>.) 
<P/>
The example uses the crossed module <C>X12</C> constructed in 
subsection <Ref Oper="XModByCentralExtension"/>. 

</Description>
</ManSection>
<Example>
<![CDATA[
gap> [ Source( X12 ), Range( X12 ) ];    
[ d12, s3 ]
gap> Boundary( X12 ); 
[ (1,2,3,4,5,6), (2,6)(3,5) ] -> [ (7,8,9), (8,9) ]
gap> XModAction( X12 );
[ (7,8,9), (8,9) ] -> 
[ [ (1,2,3,4,5,6), (2,6)(3,5) ] -> [ (1,2,3,4,5,6), (1,3)(4,6) ], 
  [ (1,2,3,4,5,6), (2,6)(3,5) ] -> [ (1,6,5,4,3,2), (2,6)(3,5) ] ]
]]>
</Example>

<ManSection>
   <Oper Name="ImageElmXModAction"
         Arg="X0, s, r" />
<Description>
This function returns the element <M>s^r</M> given by <C>XModAction(X0)</C>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> ImageElmXModAction( X12, (1,2,3,4,5,6), (8,9) );
(1,6,5,4,3,2)
]]>
</Example>

<ManSection>
   <Attr Name="Size"
         Arg="X0" Label="for crossed modules" />
   <Attr Name="Name"
         Arg="X0" Label="for crossed modules" />
   <Attr Name="IdGroup"
         Arg="X0" Label="for crossed modules" />
   <Attr Name="ExternalSetXMod"
         Arg="X0" />
<Description>
More familiar attributes are <C>Name</C>, <C>Size</C> and <C>IdGroup</C>. 
The name is formed by concatenating the names of the source and range 
(if these exist). 
<C>Size</C> and <C>IdGroup</C> return two-element lists. 
<P/> 
The <Ref Attr="ExternalSetXMod"/> for a crossed module is the source group considered as a G-set of the range group using the crossed module action. 
<P/> 
<Index>Display for a 2d-group</Index>
The <C>Display</C> function is used to print details of 2d-groups.
</Description>
</ManSection>

In the simple example below, <Code>X5</Code> is the automorphism crossed module 
constructed in subsection <Ref Oper="XModByAutomorphismGroup"/>. 
The <C>Print</C> statements at the end of the example list the &GAP; 
representations and attributes of <Code>X5</Code>. 
<P/>
<Example>
<![CDATA[
gap> Size( X5 );  IdGroup( X5 ); 
[ 5, 4 ]
[ [ 5, 1 ], [ 4, 1 ] ]
gap> ext := ExternalSetXMod( X5 ); 
<xset:[ (), (5,6,7,8,9), (5,7,9,6,8), (5,8,6,9,7), (5,9,8,7,6) ]>
gap> Orbits( ext );
[ [ () ], [ (5,6,7,8,9), (5,7,9,6,8), (5,9,8,7,6), (5,8,6,9,7) ] ]
gap> a := GeneratorsOfGroup( Range( X5 ) )[1]^2; 
[ (5,6,7,8,9) ] -> [ (5,9,8,7,6) ]
gap> ImageElmXModAction( X5, (5,7,9,6,8), a );
(5,8,6,9,7)
gap> RepresentationsOfObject( X5 );
[ "IsComponentObjectRep", "IsAttributeStoringRep", "IsPreXModObj" ]
gap> KnownAttributesOfObject( X5);
[ "Name", "Size", "Range", "Source", "IdGroup", "Boundary", "XModAction", 
  "ExternalSetXMod", "HigherDimension" ]
]]>
</Example>

</Section>


<Section Label="sect-properties-xmod">
<Heading>Properties of crossed modules</Heading>

<Index>Is2DimensionalDomain</Index>
<Index>Is2DimensionalGroup</Index>
<Index>IsTrivialAction2DimensionalGroup</Index>
<Index>IsNormalSubgroup2DimensionalGroup</Index>
<Index>IsCentralExtension2DimensionalGroup</Index>
<Index>IsAutomorphismGroup2DimensionalGroup</Index>
<Index>IsAbelianModule2DimensionalGroup</Index>

The underlying category structures for the objects constructed in this 
chapter follow the sequence <C>Is2DimensionalDomain</C>; 
<C>Is2DimensionalMagma</C>; <C>Is2DimensionalMagmaWithOne</C>; 
<C>Is2DimensionalMagmaWithInverses</C>, 
mirroring the situation for (one-dimensional) groups. 
From these we construct <C>Is2DimensionalSemigroup</C>, 
<C>Is2DimensionalMonoid</C> and <C>Is2DimensionalGroup</C>. 
<P/>
There are then a variety of properties associated with crossed modules, 
starting with <C>IsPreXMod</C> and <C>IsXMod</C>. 
<P/> 
<ManSection>
   <Prop Name="IsXMod"
         Arg="X0" />
   <Prop Name="IsPreXMod"
         Arg="X0" />
   <Prop Name="IsPerm2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsPc2DimensionalGroup"
         Arg="X0" />
   <Prop Name="IsFp2DimensionalGroup"
         Arg="X0" />
<Description>
A structure which has <C>IsPerm2DimensionalGroup</C> is a precrossed module 
or a pre-cat<M>^1</M>-group (see section <Ref Sect="sect-cat1" />) 
whose source and range are both permutation groups. 
The properties <C>IsPc2DimensionalGroup</C>, <C>IsFp2DimensionalGroup</C> 
are defined similarly. 
In the example below we see that <Code>X5</Code> has 
<C>IsPreXMod</C>, <C>IsXMod</C> and <C>IsPerm2DimensionalGroup</C>. 
There are also properties corresponding to the various construction methods 
listed in section <Ref Sect="sect-constructions" />: 
<C>IsTrivialAction2DimensionalGroup</C>; 
<C>IsNormalSubgroup2DimensionalGroup</C>; 
<C>IsCentralExtension2DimensionalGroup</C>; 
<C>IsAutomorphismGroup2DimensionalGroup</C>; 
<C>IsAbelianModule2DimensionalGroup</C>. 
</Description>
</ManSection>

<Example>
<![CDATA[
gap> KnownPropertiesOfObject( X5 );
[ "IsEmpty", "IsTrivial", "IsNonTrivial", "IsFinite", 
  "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfSemigroup", "IsPreXModDomain", "IsPreXMod", "IsXMod", 
  "IsAutomorphismGroup2DimensionalGroup" ]
]]>
</Example>

<Index>IsNormal for crossed modules</Index>
<ManSection>
   <Oper Name="SubXMod"
         Arg="X0 src rng" />
   <Attr Name="TrivialSubXMod"
         Arg="X0" />
   <Attr Name="NormalSubXMods"
         Arg="X0" />
<Description>
With the standard crossed module constructors listed above as building blocks, 
sub-crossed modules, normal sub-crossed modules 
<M>\calN \lhd \calX</M>,
and also quotients <M>\calX/\calN</M> may be constructed.
A sub-crossed module  <M>\calS = (\delta : N \to M)</M>
is <E>normal</E> in <M>\calX = (\partial : S \to R)</M>  if
<List>
<Item>
<M>N,M</M> are normal subgroups of <M>S,R</M> respectively,
</Item>
<Item>
<M>\delta</M> is the restriction of <M>\partial</M>,
</Item>
<Item>
<M>n^r \in N</M>  for all  <M>n \in N,~r \in R</M>,
</Item>
<Item>
<M>(s^{-1})^ms \in N</M>  for all  <M>m \in M,~s \in S</M>.
</Item>
</List>
These conditions ensure that  <M>M \ltimes N</M>  is normal in  
the semidirect product <M>R \ltimes S</M>. 
(Note that <M>\langle s,m \rangle = (s^{-1})^ms</M> 
is a displacement: see <Ref Func="Displacement" />.)
<P/>
A method for <C>IsNormal</C> for precrossed modules is provided. 
See section <Ref Sect="sect-more-xmod-ops"/> for factor crossed modules 
and their natural morphisms. 
<P/> 
The five normal subcrossed modules of <C>X4</C> found in the following 
example are <C>[id,id], [k4,k4], [k4,a4], [a4,a4]</C> 
and <C>X4</C> itself. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> s4 := Group( (1,2), (2,3), (3,4) );; 
gap> a4 := Subgroup( s4, [ (1,2,3), (2,3,4) ] );; 
gap> k4 := Subgroup( a4, [ (1,2)(3,4), (1,3)(2,4) ] );; 
gap> SetName(s4,"s4");  SetName(a4,"a4");  SetName(k4,"k4"); 
gap> X4 := XModByNormalSubgroup( s4, a4 );
[a4->s4]
gap> Y4 := SubXMod( X4, k4, a4 ); 
[k4->a4]
gap> IsNormal(X4,Y4);
true
gap> NX4 := NormalSubXMods( X4 );;
gap> Length( NX4 ); 
5
]]>
</Example>

<ManSection>
   <Attr Name="KernelCokernelXMod"
         Arg="X0" />
<Description>
Let <M>\calX = (\partial : S \to R)</M>. 
If <M>K \leqslant S</M> is the kernel of <M>\partial</M>,  
and <M>J \leqslant R</M> is the image of <M>\partial</M>, 
form <M>C = R/J</M>. 
Then <M>(\nu\partial|_K : K \to C)</M> is a crossed module 
where <M>\nu : R \to C, r \mapsto Jr</M> is the natural map, 
and the action of <M>C</M> on <M>K</M> is given by <M>k^{Jr} = k^r</M>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> d8d8 := Group( (1,2,3,4), (1,3), (5,6,7,8), (5,7) );;
gap> X88 := XModByAutomorphismGroup( d8d8 );;
gap> Size( X88 );
[ 64, 2048 ]
gap> Y88 := KernelCokernelXMod( X88 );;
gap> StructureDescription( Y88 );
[ "C2 x C2", "(D8 x D8) : C2" ] 
]]>
</Example>

</Section>


<Section Label="sect-precrossed-modules">
<Heading>Pre-crossed modules</Heading>

<Index>pre-crossed module</Index>
<ManSection>
   <Oper Name="PreXModByBoundaryAndAction"
         Arg="bdy act" />
   <Oper Name="SubPreXMod"
         Arg="X0 src rng" />
<Description>
If axiom  <M>{\bf XMod\ 2}</M> is <E>not</E> satisfied, 
the corresponding structure is known as a <E>pre-crossed module</E>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> b1 := (11,12,13,14,15,16,17,18);;  b2 := (12,18)(13,17)(14,16);;
gap> d16 := Group( b1, b2 );;
gap> sk4 := Subgroup( d16, [ b1^4, b2 ] );;
gap> SetName( d16, "d16" );  SetName( sk4, "sk4" );
gap> bdy16 := GroupHomomorphismByImages( d16, sk4, [b1,b2], [b1^4,b2] );;
gap> aut1 := GroupHomomorphismByImages( d16, d16, [b1,b2], [b1^5,b2] );;
gap> aut2 := GroupHomomorphismByImages( d16, d16, [b1,b2], [b1,b2^4*b2] );;
gap> aut16 := Group( [ aut1, aut2 ] );;
gap> act16 := GroupHomomorphismByImages( sk4, aut16, [b1^4,b2], [aut1,aut2] );;
gap> P16 := PreXModByBoundaryAndAction( bdy16, act16 );
[d16->sk4]
gap> IsXMod( P16 );
false
]]>
</Example>

<Index>Peiffer subgroup</Index>
<ManSection>
   <Attr Name="PeifferSubgroup"
         Arg="X0" />
   <Attr Name="XModByPeifferQuotient"
         Arg="prexmod" />
<Description>
The <E>Peiffer subgroup</E> <M>P</M> of a pre-crossed module 
<M>\calX</M> is the subgroup of <M>{\rm ker}(\partial)</M> 
generated by  <E>Peiffer commutators</E>
<Display>
\lfloor s_1,s_2 \rfloor ~=~ 
(s_1^{-1})^{\partial s_2}~s_2^{-1}~s_1~s_2 ~=~ 
\langle \partial s_2, s_1 \rangle\ [s_1,s_2]~.
</Display>
Then  <M>\calP = (0 : P \to \{1_R\})</M>
is a normal sub-pre-crossed module of  <M>\calX</M>
and  <M>\calX/\calP = (\partial : S/P \to R)</M>
is a crossed module.
<P/>
In the following example the Peiffer subgroup is cyclic of size <M>4</M>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> P := PeifferSubgroup( P16 );
Group( [ (11,15)(12,16)(13,17)(14,18), (11,17,15,13)(12,18,16,14) ] )
gap> X16 := XModByPeifferQuotient( P16 );
Peiffer([d16->sk4])
gap> Display( X16 );
Crossed module Peiffer([d16->sk4]) :-
: Source group has generators:
  [ f1, f2 ]
: Range group has generators:
  [ (11,15)(12,16)(13,17)(14,18), (12,18)(13,17)(14,16) ]
: Boundary homomorphism maps source generators to:
  [ (12,18)(13,17)(14,16), (11,15)(12,16)(13,17)(14,18) ]
  The automorphism group is trivial
gap> iso16 := IsomorphismPermGroup( Source( X16 ) );;
gap> S16 := Image( iso16 );
Group([ (1,2), (3,4) ])   
]]>
</Example>

</Section>


<Section Label="sect-cat1">
<Heading>Cat<M>^1</M>-groups and pre-cat<M>^1</M>-groups</Heading>
<Index>cat<M>^1</M>-group</Index>

In <Cite Key="L1" />, Loday reformulated the notion of a 
crossed module as a cat<M>^1</M>-group, 
namely a group <M>G</M> with a pair of endomorphisms <M>t,h : G \to G</M>
having  a common image <M>R</M> and satisfying certain axioms.
We find it computationally convenient to define a cat<M>^1</M>-group 
<M>\calC = (e;t,h : G \to R )</M>  as having source group  <M>G</M>,
range group <M>R</M>,  and three homomorphisms:  two surjections  
<M>t,h : G \to R</M>  and an embedding  <M>e : R \to G</M>  satisfying:
<Display>
{\bf Cat\ 1}  :  ~t \circ e ~=~ h \circ e = {\rm id}_R,
\qquad
{\bf Cat\ 2}  :  ~[\ker t, \ker h] ~=~ \{ 1_G \}.
</Display>
It follows that  
<M>\;t \circ e \circ h = h,~ h \circ e \circ t = t,~ 
     t \circ e \circ t = t~</M> 
and <M>~h \circ e \circ h = h</M>. 
(See section <Ref Sect="sect-properties-cat1"/> for the case when 
<M>t,h</M> are endomorphisms.) 

<ManSection Label="mansect-cat1">
   <Func Name="Cat1Group"
         Arg="args" />
   <Func Name="PreCat1Group"
         Arg="args" />
   <Oper Name="PreCat1GroupByTailHeadEmbedding"
         Arg="t h e" />
   <Oper Name="PreCat1GroupWithIdentityEmbedding"
         Arg="t h" />
<Description>
The global functions <C>Cat1Group</C> and <C>PreCat1Group</C> 
can be called in various ways. 
<List>
<Item>
as <C>Cat1Group(t,h,e);</C> when <M>t,h,e</M> are three homomorphisms, 
which is equivalent to <C>PreCat1GroupByTailHeadEmbedding(t,h,e);</C> 
</Item>
<Item>
as <C>Cat1Group(t,h);</C> when <M>t,h</M> are two endomorphisms, 
which is equivalent to <C>PreCat1GroupWithIdentityEmbedding(t,h);</C> 
</Item>
<Item>
as <C>Cat1Group(t);</C> when <M>t=h</M> is an endomorphism, 
which is equivalent to <C>PreCat1GroupWithIdentityEmbedding(t,t);</C> 
</Item>
<Item>
as <C>Cat1Group(t,e);</C> when <M>t=h</M> and <M>e</M> are homomorphisms, 
which is equivalent to <C>PreCat1GroupByTailHeadEmbedding(t,t,e);</C> 
</Item>
<Item>
as <C>Cat1Group(i,j,k);</C> when <M>i,j,k</M> are integers, 
which is equivalent to <C>Cat1Select(i,j,k);</C> 
as described in section <Ref Sect="sect-cat1select"/>. 
</Item>
</List>
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> g18gens := [ (1,2,3), (4,5,6), (2,3)(5,6) ];;     
gap> s3agens := [ (7,8,9), (8,9) ];;                
gap> g18 := Group( g18gens );;  SetName( g18, "g18" ); 
gap> s3a := Group( s3agens );;  SetName( s3a, "s3a" );
gap> t1 := GroupHomomorphismByImages(g18,s3a,g18gens,[(7,8,9),(),(8,9)]);     
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (), (8,9) ]
gap> h1 := GroupHomomorphismByImages(g18,s3a,g18gens,[(7,8,9),(7,8,9),(8,9)]);
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (7,8,9), (8,9) ]
gap> e1 := GroupHomomorphismByImages(s3a,g18,s3agens,[(1,2,3),(2,3)(5,6)]);   
[ (7,8,9), (8,9) ] -> [ (1,2,3), (2,3)(5,6) ]
gap> C18 := Cat1Group( t1, h1, e1 );
[g18=>s3a]
]]>
</Example>

<ManSection>
   <Attr Name="Source"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="Range"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="TailMap"
         Arg="C" />
   <Attr Name="HeadMap"
         Arg="C" />
   <Attr Name="RangeEmbedding"
         Arg="C" />
   <Attr Name="KernelEmbedding"
         Arg="C" />
   <Attr Name="Boundary"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="Name"
         Arg="C" Label="for cat1-groups" />
   <Attr Name="Size"
         Arg="C" Label="for cat1-groups" />
<Description> 
These are the attributes of a cat<M>^1</M>-group <M>\calC</M> 
in this implementation.
<P/>
The maps  <M>t,h</M>  are often referred to as the 
<E>source</E> and <E>target</E>,
but we choose to call them the
<E>tail</E> and <E>head</E> of  <M>\calC</M>, 
because <E>source</E> is the &GAP; term for the domain of a function.
The <C>RangeEmbedding</C> is the embedding of <C>R</C> in <C>G</C>,
the <C>KernelEmbedding</C> is the inclusion of 
the kernel of <C>t</C> in <C>G</C>,
and the <C>Boundary</C> is the restriction of <C>h</C> 
to the kernel of <C>t</C>. 
It is frequently the case that <M>t=h</M>, 
but not in the example <C>C18</C> above. 
</Description>
</ManSection>
<Example>
<![CDATA[
gap> [ Source( C18 ), Range( C18 ) ];
[ g18, s3a ]
gap> TailMap( C18 );
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (), (8,9) ]
gap> HeadMap( C18 );
[ (1,2,3), (4,5,6), (2,3)(5,6) ] -> [ (7,8,9), (7,8,9), (8,9) ]
gap> RangeEmbedding( C18 );
[ (7,8,9), (8,9) ] -> [ (1,2,3), (2,3)(5,6) ]
gap> Kernel( C18 );
Group([ (4,5,6) ])
gap> KernelEmbedding( C18 );
[ (4,5,6) ] -> [ (4,5,6) ]
gap> Name( C18 );
"[g18=>s3a]"
gap> Size( C18 );
[ 18, 6 ]
gap> StructureDescription( C18 );
[ "(C3 x C3) : C2", "S3" ]
]]>
</Example>

The next four subsections contain some more constructors for 
cat<M>^1</M>-groups. 

<ManSection>
   <Oper Name="DiagonalCat1Group" 
         Arg="genG" />
<Description>
This operation constructs examples of cat<M>^1</M>-groups of the form 
<M>G \times G \Rightarrow G</M>. 
The tail map is the identity on the first factor and kills of the second, 
while the head map does the reverse. 
The range embedding maps <M>G</M> to the diagonal in <M>G \times G</M>. 
The corresponding crossed module is isomorphic to the identity crossed 
module on <M>G</M>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> C4 := DiagonalCat1Group( [ (1,2,3), (2,3,4) ] );;
gap> SetName( Source(C4), "a4a4" );  SetName( Range(C4_, "a4d" );
gap> Display( C4 );
Cat1-group [a4a4=>a4d] :- 
: Source group a4a4 has generators:
  [ (1,2,3), (2,3,4), (5,6,7), (6,7,8) ]
: Range group a4d has generators:
  [ ( 9,10,11), (10,11,12) ]
: tail homomorphism maps source generators to:
  [ ( 9,10,11), (10,11,12), (), () ]
: head homomorphism maps source generators to:
  [ (), (), ( 9,10,11), (10,11,12) ]
: range embedding maps range generators to:
  [ (1,2,3)(5,6,7), (2,3,4)(6,7,8) ]
: kernel has generators:
  [ (5,6,7), (6,7,8) ]
: boundary homomorphism maps generators of kernel to:
  [ ( 9,10,11), (10,11,12) ]
: kernel embedding maps generators of kernel to:
  [ (5,6,7), (6,7,8) ]
]]>
</Example>

<ManSection>
   <Attr Name="TransposeCat1Group"
         Arg="C0" />
   <Attr Name="TransposeIsomorphism"
         Arg="C0" />
<Description> 
The <E>transpose</E> of a cat<M>^1</M>-group <M>C</M> 
has the same source, range and embedding, 
but has the tail and head maps interchanged. 
The <C>TransposeIsomorphism</C> gives the isomorphism between the two. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> R4 := TransposeCat1Group( C4 );
[a4a4=>a4d]
gap> Boundary( R4 );
[ (2,3,4), (1,2,3) ] -> [ (10,11,12), (9,10,11) ]
gap> TailMap( R4 ) = HeadMap( R4 ); 
false
gap> TailMap( R4 ) = HeadMap( C4 ); 
true
gap> MappingGeneratorsImages( TransposeIsomorphism(C4) );
[ [ [ (1,2,3), (2,3,4), (5,6,7), (6,7,8) ], 
      [ (5,6,7), (6,7,8), (1,2,3), (2,3,4) ] ], 
  [ [ (9,10,11), (10,11,12) ], [ (9,10,11), (10,11,12) ] ] ]
]]>
</Example>

<ManSection>
   <Oper Name="Cat1GroupByPeifferQuotient"
         Arg="P" />
<Description>
If <M>C = (e;t,h : G \to R)</M> is a pre-cat<M>^1</M>-group, 
its Peiffer subgroup is <M>P = [\ker t,\ker h]</M> 
and the associated cat<M>^1</M>-group <M>C_2</M> has source <M>G/P</M>. 
In the example, <M>t=h : s4 \to c2</M> with <M>\ker t = \ker h = a4</M> 
and <M>P = [a4,a4]=k4</M>, so that <M>G/P = s4/k4 \cong s3</M>. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> s4 := Group( (1,2,3), (3,4) );;  SetName( s4, "s4" ); 
gap> h := GroupHomomorphismByImages( s4, s4, [(1,2,3),(3,4)], [(),(3,4)] );;
gap> c2 := Image( h );;  SetName( c2, "c2" );
gap> C := PreCat1Group( h, h );
[s4=>c2]
gap> P := PeifferSubgroupPreCat1Group( C );
Group([ (1,3)(2,4), (1,2)(3,4) ])
gap> C2 := Cat1GroupByPeifferQuotient( C );
[Group( [ f1, f2 ] )=>c2]
gap> StructureDescription( C2 );
[ "S3", "C2" ]
gap> rec2 := PreXModRecordOfPreCat1Group( C );;
gap> XC := rec2.prexmod;;
gap> StructureDescription( XC );  
[ "A4", "C2" ]
gap> XC2 := XModByPeifferQuotient( XC );;
gap> StructureDescription( XC2 );
[ "C3", "C2" ]
gap> CXC2 := Cat1GroupOfXMod( XC2 );;
gap> StructureDescription( CXC2 );
[ "S3", "C2" ]
gap> IsomorphismCat1Groups( C2, CXC2 );
[[Group( [ f1, f2 ] ) => c2] => [(..|X..) => c2]]
]]>
</Example>

<ManSection>
   <Oper Name="SubCat1Group"
         Arg="C1 S1" />
   <Oper Name="SubPreCat1Group"
         Arg="C1 S1" />
<Description>
<M>S_1</M> is a sub-cat<M>^1</M>-group of <M>C_1</M> 
provided the source and range of <M>S_1</M> 
are subgroups of the source and range of <M>C_1</M> 
and that the tail, head and embedding of <M>S_1</M> 
are the appropriate restrictions of those of <M>C_1</M>. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> s3 := Subgroup( s4, [(2,3),(3,4)] );; 
gap> res := DoublyRestrictedMapping( h, s3, s3 );; 
gap> S := PreCat1Group( res, res );
[Group( [ (2,3), (3,4) ] )=>Group( [ (3,4), (3,4) ] )]
]]>
</Example>

<ManSection>
   <Oper Name="DirectProduct"
         Arg="C1 C2" Label="for cat1-groups" />
<Description>
The direct product  <M>\calC_{1} \times \calC_{2}</M>
of two cat<M>^1</M>-groups has source  <M>G_1 \times G_2</M> 
and range  <M>R_1 \times R_2</M>. 
The tail, head and embedding maps are 
<M>t_1 \times t_2</M>, <M>h_1 \times h_2</M> and <M>e_1 \times e_2</M>. 
The embeddings and projections are constructed automatically, 
and placed in the <C>DirectProductInfo</C> attribute, 
together with the two <E>objects</E> <M>\calC_{1}</M> and <M>\calC_{2}</M>. 
<P/> 
The example constructs the product of two of the cat<M>^1</M>-groups 
constructed above. 
<P/>
</Description>
</ManSection>
<Example>
<![CDATA[
gap> C418 := DirectProduct( C4, C18 );
[(a4a4xg18)=>(a4d x s3a)]
gap> infoC418 := DirectProductInfo( C418 );
rec( 
  embeddings := [ [[a4a4=>a4d] => [(a4a4xg18)=>(a4d x s3a)]], 
      [[g18=>s3a] => [(a4a4xg18)=>(a4d x s3a)]] ], 
  objects := [ [a4a4=>a4d], [g18=>s3a] ], 
  projections := [ [[(a4a4xg18)=>(a4d x s3a)] => [a4a4=>a4d]], 
      [[(a4a4xg18)=>(a4d x s3a)] => [g18=>s3a]] ] )
gap> t418 := TailMap( C418 );
[ (1,2,3), (2,3,4), (5,6,7), (6,7,8), (9,10,11), (12,13,14), (10,11)(13,14) 
 ] -> [ (1,2,3), (2,3,4), (), (), (5,6,7), (), (6,7) ]
gap> h418 := HeadMap( C418 );
[ (1,2,3), (2,3,4), (5,6,7), (6,7,8), (9,10,11), (12,13,14), (10,11)(13,14) 
 ] -> [ (), (), (1,2,3), (2,3,4), (5,6,7), (5,6,7), (6,7) ]
gap> e418 := RangeEmbedding( C418 );
[ (1,2,3), (2,3,4), (5,6,7), (6,7) ] -> [ (1,2,3)(5,6,7), (2,3,4)(6,7,8), 
  (9,10,11), (10,11)(13,14) ]
]]>
</Example>

</Section> 

<Section Label="sect-properties-cat1">
<Heading>
Properties of cat<M>^1</M>-groups and pre-cat<M>^1</M>-groups 
</Heading>

Many of the properties listed in section <Ref Sect="sect-properties-xmod"/> 
apply to pre-cat<M>^1</M>-groups and to cat<M>^1</M>-groups 
since these are also 2d-groups. 
There are also more specific properties. 

<ManSection>
   <Prop Name="IsCat1Group"
         Arg="C0" />
   <Prop Name="IsPreXCat1Group"
         Arg="C0" />
   <Prop Name="IsIdentityCat1Group"
         Arg="C0" />
<Description>
<C>IsIdentityCat1Group(C0)</C> is true when the head and tail maps of <C>C0</C> 
are identity mappings. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> G8 := SmallGroup( 288, 956 );  SetName( G8, "G8" );
<pc group of size 288 with 7 generators>
gap> d12 := DihedralGroup( 12 );  SetName( d12, "d12" );
<pc group of size 12 with 3 generators>
gap> a1 := d12.1;;  a2 := d12.2;;  a3 := d12.3;;  a0 := One( d12 );;
gap> gensG8 := GeneratorsOfGroup( G8 );;
gap> t8 := GroupHomomorphismByImages( G8, d12, gensG8,
>           [ a0, a1*a3, a2*a3, a0, a0, a3, a0 ] );;
gap> h8 := GroupHomomorphismByImages( G8, d12, gensG8,
>           [ a1*a2*a3, a0, a0, a2*a3, a0, a0, a3^2 ] );;                   
gap> e8 := GroupHomomorphismByImages( d12, G8, [a1,a2,a3],
>        [ G8.1*G8.2*G8.4*G8.6^2, G8.3*G8.4*G8.6^2*G8.7, G8.6*G8.7^2 ] );
[ f1, f2, f3 ] -> [ f1*f2*f4*f6^2, f3*f4*f6^2*f7, f6*f7^2 ]
gap> C8 := PreCat1GroupByTailHeadEmbedding( t8, h8, e8 );
[G8=>d12]
gap> IsCat1Group( C8 );
true
gap> KnownPropertiesOfObject( C8 );
[ "CanEasilyCompareElements", "CanEasilySortElements", "IsDuplicateFree", 
  "IsGeneratorsOfSemigroup", "IsPreCat1Domain", "IsPc2DimensionalGroup", 
  "IsPreXMod", "IsPreCat1Group", "IsCat1Group", "IsIdentityPreCat1Group", 
  "IsPreCat1GroupWithIdentityEmbedding" ]
]]>
</Example>

<ManSection>
   <Prop Name="IsPreCat1GroupWithIdentityEmbedding"
         Arg="C0" />
   <Attr Name="IsomorphicPreCat1GroupWithIdentityEmbedding" 
         Arg="C0" /> 
   <Attr Name="IsomorphismToPreCat1GroupWithIdentityEmbedding" 
         Arg="C0" /> 
<Description>
<C>IsPreCat1GroupWithIdentityEmbedding(C0)</C> is true when the range 
embedding of <C>C0</C> is an inclusion mapping. 
(This property used to be called <C>IsPreCat1GroupByEndomorphisms</C> but, 
as the example below shows, when the tail and head maps are endomorphisms 
the range embedding need not be an inclusion.) 
When this is not the case, replacing <M>t,h,e</M> by <M>t*e,h*e</M> 
and the inclusion mapping of the image of <M>e</M> gives an isomorphic 
cat<M>^1</M>-group for which <C>IsPreCat1GroupWithIdentityEmbedding</C> is true. 
This is the <C>IsomorphicPreCat1GroupWithIdentityEmbedding</C> of <C>C0</C> and 
<C>IsomorphismToPreCat1GroupWithIdentityEmbedding</C> is the isomorphism 
between them. (See the next chapter for mappings of cat<M>^1</M>-groups.) 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> G5 := Group( (1,2,3,4,5) );;                                             
gap> t := GroupHomomorphismByImages( G5, G5, [(1,2,3,4,5)], [(1,5,4,3,2)] );;
gap> PC5 := PreCat1GroupByTailHeadEmbedding( t, t, t );
[Group( [ (1,2,3,4,5) ] )=>Group( [ (1,2,3,4,5) ] )]
gap> IsPreCat1GroupWithIdentityEmbedding( PC5 );
false
gap> IPC5 := IsomorphicPreCat1GroupWithIdentityEmbedding( PC5 );
[Group( [ (1,2,3,4,5) ] )=>Group( [ (1,2,3,4,5) ] )]
gap> TailMap( IPC5 ); RangeEmbedding( IPC5 );
[ (1,2,3,4,5) ] -> [ (1,2,3,4,5) ]
[ (1,2,3,4,5) ] -> [ (1,2,3,4,5) ]
]]>
</Example>



<ManSection>
   <Attr Name="Cat1GroupOfXMod"
         Arg="X0" />
   <Attr Name="XModOfCat1Group"
         Arg="C0" />
   <Attr Name="PreCat1GroupRecordOfPreXMod"
         Arg="P0" />
   <Attr Name="PreXModRecordOfPreCat1Group"
         Arg="P0" />
<Description>
The category of crossed modules is equivalent to the category of 
cat<M>^1</M>-groups, and the functors between these two categories 
may be described as follows.

Starting with the crossed module 
<M>\calX = (\partial : S \to R)</M> the group <M>G</M> is defined 
as the semidirect product <M>G = R \ltimes S</M>
using the action from  <M>\calX</M>,
with multiplication rule
<Display>
(r_1,s_1)(r_2,s_2) ~=~ (r_1r_2,{s_1}^{r_2}s_2).
</Display>
The structural morphisms are given by
<Display>
t(r,s) = r, \quad h(r,s) = r (\partial s), \quad er = (r,1).
</Display>
On the other hand, starting with a cat<M>^1</M>-group 
<M> \calC = (e;t,h : G \to R)</M>,  we define 
<M> S = \ker t</M>, the range <M>R</M> is unchanged, and 
<M> \partial = h\!\mid_S </M>.
The action of  <M>R</M>  on  <M>S</M>  is conjugation in  <M>G</M>  via the embedding
of  <M>R</M>  in  <M>G</M>.
<P/>
As from version 2.74, the attribute <C>PreCat1GroupRecordOfPreXMod</C> 
of a pre-crossed modute <M>X = (\partial : S \to R)</M> 
returns a record with fields 
<List>
<Item>
<C>.precat1</C>, the pre-cat1-group <M>C = (e;t,h: G \to R)</M> of <M>X</M>, 
where <M>G = R \ltimes S</M>; 
</Item>
<Item>
<C>.iscat1</C>, true if <M>C</M> is a cat1-group; 
</Item>
<Item>
<C>.xmodSourceEmbedding</C>, the image <M>S'</M> of <M>S</M> in <M>G</M>; 
</Item>
<Item>
<C>.xmodSourceEmbeddingIsomorphism</C>, the isomorphism <M>S \to S'</M>; 
</Item>
<Item>
<C>.xmodRangeEmbedding</C>, the image <M>R'</M> of <M>R</M> in <M>G</M>; 
</Item>
<Item>
<C>.xmodRangeEmbeddingIsomorphism</C>, the isomorphism <M>R \to R'</M>; 
</Item>
</List>
<P/>
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> X8 := XModOfCat1Group( C8 );;
gap> Display( X8 );

Crossed module X([G8=>d12]) :- 
: Source group has generators:
  [ f1, f4, f5, f7 ]
: Range group d12 has generators:
  [ f1, f2, f3 ]
: Boundary homomorphism maps source generators to:
  [ f1*f2*f3, f2*f3, <identity> of ..., f3^2 ]
: Action homomorphism maps range generators to automorphisms:
  f1 --> { source gens --> [ f1*f5, f4*f5, f5, f7^2 ] }
  f2 --> { source gens --> [ f1*f5*f7^2, f4, f5, f7 ] }
  f3 --> { source gens --> [ f1*f7, f4, f5, f7 ] }
  These 3 automorphisms generate the group of automorphisms.
: associated cat1-group is [G8=>d12]

gap> StructureDescription(X8);
[ "D24", "D12" ]

]]>
</Example>
</Section>


<Section Label="sect-allcat1">
<Heading>Enumerating cat<M>^1</M>-groups with a given source</Heading>

As the size of a group <M>G</M> increases, the number of cat<M>^1</M>-groups 
with source <M>G</M> increases rapidly.  
However, one is usually only interested in the isomorphism classes 
of cat<M>^1</M>-groups with source <M>G</M>. 
An iterator <C>AllCat1GroupsIterator</C> is provided, 
which runs through the various cat<M>^1</M>-groups. 
This iterator finds, for each subgroup <M>R</M> of <M>G</M>, 
the cat<M>^1</M>-groups with range <M>R</M>. 
It does this by running through the <C>AllSubgroupsIterator(G)</C> 
provided by the <Package>Utils</Package> package, 
and then using the iterator <C>AllCat1GroupsWithImageIterator(G,R)</C>. 

<ManSection>
   <Oper Name="AllCat1GroupsWithImageIterator"
         Arg="G R" />
   <Attr Name="AllCat1GroupsWithImageNumber"
         Arg="G R" />
   <Oper Name="AllCat1GroupsWithImageUpToIsomorphism"
         Arg="G R" />
   <Oper Name="AllCat1GroupsWithImage"
         Arg="G R" />
<Description>
The iterator <C>AllCat1GroupsWithImageIterator(G,R)</C> 
iterates through all the cat<M>^1</M>-groups with source <C>G</C> 
and range <M>R</M>. 
The attribute <C>AllCat1GroupsWithImageNumber(G)</C> runs through this iterator to count the number <M>n_R</M> of these cat<M>^1</M>-groups. 
The operation <C>AllCat1GroupsWithImage(G)</C> returns a list containing 
these <M>n_R</M> cat<M>^1</M>-groups.  
Since these lists can get very long, this operation should only 
be used for simple cases. 
The operation <C>AllCat1GroupsWithImageUpToIsomorphism(G)</C> returns 
representatives of the isomorphism classes of these cat<M>^1</M>-groups. 
</Description> 
</ManSection>
<P/>
<Example>
<![CDATA[
gap> d12 := DihedralGroup( IsPermGroup, 12 );  SetName( d12, "d12" );
Group([ (1,2,3,4,5,6), (2,6)(3,5) ])
gap> c2 := Subgroup( d12, [ (1,6)(2,5)(3,4) ] );; 
gap> AllCat1GroupsWithImageNumber( d12, c2 );
1
gap> L12 := AllCat1GroupsWithImage( d12, c2 );
[ [d12=>Group( [ (), (1,6)(2,5)(3,4) ] )] ]
]]>
</Example>

<ManSection>
   <Attr Name="AllCat1GroupsMatrix"
         Arg="G" />
<Description>
The operation <C>AllCat1GroupsMatrix(G)</C> constructs a symmetric matrix 
<M>M</M> with rows and columns labelled by the idempotent endomorphisms 
<M>e_i</M> on <M>G</M>, where <M>M_{ij}</M> is 
<M>2</M> if <M>e_i,e_j</M> combine to form a cat<M>^1</M>-group; 
<M>1</M> if they only form a pre-cat<M>^1</M>-group; 
and <M>0</M> otherwise.  The matrix is automatically printed out 
with dots in place of zeroes. 
<P/> 
In the example we see that the group <M>QD_{16}</M> 
has <M>10</M> idempotent endomorphisms and <M>5</M> cat<M>12</M>-groups, 
all of which are symmetric(<M>t=h)</M>, 
and a further <M>9</M> pre-cat<M>^1</M>-groups. 
(A cat<M>^1</M>-group and its transpose are not counted twice.) 
This operation is intended to be used to illustrate how cat<M>^2</M>-groups 
are formed, and should only be used with groups of low order. 
<P/> 
The attribute <C>AllCat1GroupsNumber(G)</C> returns the  
number <M>n</M> of these cat<M>^1</M>-groups. 
</Description> 
</ManSection>
<P/>
<Example>
<![CDATA[
gap> AllCat1GroupsMatrix( G );;                 
number of cat1-groups found = 5
number of additional pre-cat1-groups found = 9
1.........
.21.......
.11.......
...21.....
...11.....
.....21...
.....11...
.......21.
.......11.
.........2
]]>
</Example>

<ManSection>
   <Oper Name="AllCat1GroupsIterator"
         Arg="G" />
   <Oper Name="AllCat1GroupsUpToIsomorphism"
         Arg="G" />
   <Oper Name="AllCat1GroupsMatrix"
         Arg="G" />
   <Oper Name="AllCat1Groups"
         Arg="G" />
<Description>
The iterator <C>AllCat1GroupsIterator(G)</C> iterates through all the 
cat<M>^1</M>-groups with source <C>G</C>. 
The operation <C>AllCat1Groups(G)</C> returns a list containing these <M>n</M> 
cat<M>^1</M>-groups.  
Since these lists can get very long, this operation should only 
be used for simple cases. 
The operation <C>AllCat1GroupsUpToIsomorphism(G)</C> returns representatives 
of the isomorphism classes of these subgroups. 
</Description> 
</ManSection>
<P/>
<Example>
<![CDATA[
gap> iter := AllCat1GroupsIterator( d12 );;
gap> AllCat1GroupsNumber( d12 );
12
gap> iso12 := AllCat1GroupsUpToIsomorphism( d12 );
[ [d12=>Group( [ (), (2,6)(3,5) ] )], 
  [d12=>Group( [ (1,4)(2,5)(3,6), (2,6)(3,5) ] )], 
  [d12=>Group( [ (1,5,3)(2,6,4), (2,6)(3,5) ] )], 
  [d12=>Group( [ (1,2,3,4,5,6), (2,6)(3,5) ] )] ]
]]>
</Example>

<ManSection>
   <Attr Name="CatnGroupNumbers"
         Arg="G" Label="for cat1-groups" />
   <Attr Name="CatnGroupLists"
         Arg="G" Label="for cat1-groups" />
   <Oper Name="InitCatnGroupRecords"
         Arg="G" />
<Description>
The attribute <C>CatnGroupNumbers</C> for a group <M>G</M> 
is a mutable record which stores numbers of cat<M>^1</M>-groups, 
cat<M>^2</M>-groups, etc. as they are calculated. 
The field <C>CatnGroupNumbers(G).idem</C> is the number of idempotent 
endomorphisms of <M>G</M>. 
Similarly, <C>CatnGroupNumbers(G).cat1</C> is the number of cat<M>^1</M>-groups 
on <M>G</M>, while <C>CatnGroupNumbers(G).iso1</C> is the number of 
isomorphism classes of these cat<M>^1</M>-groups. 
Also <C>CatnGroupNumbers(G).symm</C> is the number of cat<M>^1</M>-groups 
whose <C>TailMap</C> is the same as the <C>HeadMap</C>, while <C>CatnGroupNumbers(G).siso</C> is the number of 
isomorphism classes of these symmetric cat<M>^1</M>-groups. 
Symmetric cat<M>^1</M>-groups are in one-one correspondence with 
symmetric cat<M>^2</M>-groups.  
The attribute <C>CatnGroupLists</C> is used for storing results 
of cat<M>^2</M>-group calculations. 
</Description> 
</ManSection>
<P/>
<Example>
<![CDATA[
gap> CatnGroupNumbers( d12 );
rec( cat1 := 12, idem := 21, iso1 := 4, siso := 4, symm := 12 )
]]>
</Example>
</Section> 



<Section Label="sect-cat1select">
<Heading>Selection of a small cat<M>^1</M>-group</Heading>
<Index>selection of a small cat<M>^1</M>-group</Index>

The <C>Cat1Group</C> function may also be used to select a cat<M>^1</M>-group 
from a data file.
All cat<M>^1</M>-structures on groups of size up to <M>60</M> 
(ordered according to the &GAP; 4 numbering of small groups) 
are stored in a list in file <F>cat1data.g</F>.
Global variables <C>CAT1&uscore;LIST&uscore;MAX&uscore;SIZE := 60</C>,
<Index>CAT1_LIST_MAX_SIZE</Index> 
<C>CAT1&uscore;LIST&uscore;CLASS&uscore;SIZES</C> 
and <C>CAT1&uscore;LIST&uscore;NUMBERS</C> are also stored. 
<Index>CAT1_LIST_NUMBERS</Index> 
The second of these just stores the number of isomorphism classes of 
groups of size <C>size</C>. 
The third stores the numbers of isomorphism classes of cat<M>^1</M>-groups 
for each of these groups. 
The data is read into the list <C>CAT1&uscore;LIST</C> 
only when this function is called. 
<P/> 
This data was available in early versions of <Package>XMod</Package>
with groups up to order <M>70</M> covered.  
More recently a larger range of groups has become available in the package 
<Package>HAP</Package>. 
The authors are indebted to Van Luyen Le in Galway for pointing out a number 
of errors in the version of this list distributed up to version 
<B>2.24</B> of this package. 


<ManSection>
   <Oper Name="Cat1Select"
         Arg="size gpnum num" />
<Description>
The function <C>Cat1Select</C> returns the cat<M>^1</M>-group 
numbered <C>num</C> whose source is the group 
<C>G := SmallGroup(size,gpnum)</C>.
When <M>|G| \leqslant 60</M> the data file in this package is used. 
For larger groups <C>SmallCat1Group</C> (see <Ref Sect="sect-hap" />) 
is called, accessing the datafile in package <Package>HAP</Package>. 
<P/>

<P/>
The example below is the first case in which <M>t \neq h</M>
and the associated conjugation crossed module
is given by the normal subgroup <C>c3</C> of <C>s3</C>.
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> L18 := Cat1Select( 18 ); 
Usage:  Cat1Select( size, gpnum, num );  where gpnum <= 5
fail
gap> ## check the number of cat1-structures on the fourth group of order 18 
gap> Cat1Select( 18, 4 );
Usage:  Cat1Select( size, gpnum, num );  where num <= 4
fail
gap> ## select the second of these cat1-structures 
gap> B18 := Cat1Select( 18, 4, 2 );
[(C3 x C3) : C2=>Group( [ f1, <identity> of ..., f3 ] )]
gap> ## convert from a pc-cat1-group to a permutation cat1-group
gap> iso18 := IsomorphismPermObject( B18 );;
gap> PB18 := Image( iso18 );;
gap> Display( PB18 );
Cat1-group :- 
: Source group has generators:
  [ (4,5,6), (1,2,3), (2,3)(5,6) ]
: Range group has generators:
  [ (1,2,3), (2,3)(5,6) ]
: tail homomorphism maps source generators to:
  [ (), (1,2,3), (2,3)(5,6) ]
: head homomorphism maps source generators to:
  [ (), (1,2,3), (2,3)(5,6) ]
: range embedding maps range generators to:
  [ (1,2,3), (2,3)(5,6) ]
: kernel has generators:
  [ (4,5,6) ]
: boundary homomorphism maps generators of kernel to:
  [ () ]
: kernel embedding maps generators of kernel to:
  [ (4,5,6) ]
: associated crossed module is [Group( [ (4,5,6) ] ) -> Group( 
[ (1,2,3), (2,3)(5,6) ] )]
gap> convert the result to the associated permutation crossed module 
gap> Y18 := XModOfCat1Group( PB18 );; 
gap> Display( Y18 ); 
Crossed module :- 
: Source group has generators:
  [ (4,5,6) ]
: Range group has generators:
  [ (1,2,3), (2,3)(5,6) ]
: Boundary homomorphism maps source generators to:
  [ () ]
: Action homomorphism maps range generators to automorphisms:
  (1,2,3) --> { source gens --> [ (4,5,6) ] }
  (2,3)(5,6) --> { source gens --> [ (4,6,5) ] }
  These 2 automorphisms generate the group of automorphisms.
: associated cat1-group is [Group( [ (4,5,6), (1,2,3), (2,3)(5,6) 
 ] ) => Group( [ (1,2,3), (2,3)(5,6) ] )]
]]>
</Example>

</Section>


<Section Label="sect-extra-fns">
<Heading>More functions for crossed modules and cat<M>^1</M>-groups</Heading>

Chapter <Ref Chap="chap-isclnc" /> contains functions for quotient 
crossed modules; centre of a crossed module; 
commutator and derived subcrossed modules; etc. 
<P/> 
Here we mention two functions for groups which have been extended to the 
two-dimensional case. 
<P/>
<ManSection>
   <Oper Name="IdGroup" 
         Arg="2DimensionalGroup" Label="for 2d-groups" /> 
   <Oper Name="StructureDescription" 
         Arg="2DimensionalGroup" Label="for 2d-groups" /> 
<Description>
These functions return two-element lists formed by applying the function 
to the source and range of the 2d-group. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> IdGroup( X8 );
[ [ 24, 6 ], [ 12, 4 ] ]
gap> StructureDescription( C8 );
[ "(S3 x D24) : C2", "D12" ]
]]>
</Example>

There are also a number of functions which test for sub-structures.
<P/>
<ManSection>
   <Oper Name="IsSubXMod" 
         Arg="X0 S0" /> 
   <Oper Name="IsSubPreXMod" 
         Arg="X0 S0" /> 
   <Oper Name="IsSubCat1Group" 
         Arg="G0 R0" /> 
   <Oper Name="IsSubPreCat1Group" 
         Arg="G0 R0" /> 
   <Oper Name="IsSub2DimensionalGroup" 
         Arg="G0 R0" /> 
<Description>
These functions test whether the second argument is a sub-2d-group 
of the first argument. 
The examples refer back to sub-2d-groups created in sections 
<Ref Sect="sect-properties-xmod" /> and 
<Ref Sect="sect-cat1" />. 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> IsSubXMod( X4, Y4 );
true
gap> IsSubPreCat1Group( C, S );
true
]]>
</Example>

</Section>


<Section Label="sect-gpgpd">
<Heading>The group groupoid associated to a cat<M>^1</M>-group</Heading>

A <E>group groupoid</E> is an algebraic object which is both 
a groupoid and a group.  
The category of group groupoids is equivalent to the categories of 
precrossed modules and precat<M>^1</M>-groups. 
Starting with a (pre)cat<M>^1</M>-group <M>\calC = (e;t,h : G \to R)</M>, 
we form the groupoid <M>\calG</M> having the elements of 
<M>R</M> as objects and the elements of <M>G</M> as arrows. 
The arrow <M>g</M> has tail <M>tg</M> and head <M>hg</M>. 
<M>\calG</M> has one connected component for each 
coset of <M>tG</M> in <M>R</M>. 
<P/>
The groupoid (partial) multiplication <M>*</M> on these arrows is defined by: 
<Display>
(g_1 : r_1 \to r_2) * (g_2 : r_2 \to r_3) ~=~ (g_1(er_2^{-1})g_2 : r_1 \to r_3). 
</Display> 
<P/>
<ManSection>
   <Attr Name="GroupGroupoid" 
         Arg="precat1" /> 
<Description>
The operation <C>GroupGroupoid</C> implements this construction. 
In the example we start with a crossed module <M>(C_3^2 \to S_3)</M>, 
form the associated cat<M>^1</M>-group 
<M>(S_3 \ltimes C_3^2 \Rightarrow S_3)</M>,
and then form the group groupoid <C>gpd33</C>. 
Since the image of the boundary of the crossed module is <M>C_3</M>, 
with index <M>2</M> in the range, the groupoid has two connected components, 
and the root objects are <M>\{(),(12,13)\}</M>. 
The size of the vertex groups is <M>|\ker t \cap \ker h| = 3</M>, 
and the generators at the root objects are 
<M>() \to ( 4, 5, 6)( 7, 9, 8) \to ()</M> 
and <M>(12,13) \to ( 2, 3)( 4, 6)( 7, 8) \to (12,13)</M>. 
<P/> 
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> s3 := Group( (11,12), (12,13) );; 
gap> c3c3 := Group( [ (14,15,16), (17,18,19) ] );; 
gap> bdy := GroupHomomorphismByImages( c3c3, s3, 
>        [(14,15,16),(17,18,19)], [(11,12,13),(11,12,13)] );;
gap> a := GroupHomomorphismByImages( c3c3, c3c3, 
>        [(14,15,16),(17,18,19)], [(14,16,15),(17,19,18)] );; 
gap> aut := Group( [a] );; 
gap> act := GroupHomomorphismByImages( s3, aut, [(11,12),(12,13)], [a,a] );;
gap> X33 := XModByBoundaryAndAction( bdy, act );; 
gap> C33 := Cat1GroupOfXMod( X33 ).precat1;; 
gap> G33 := Source( C33 );; 
gap> gpd33 := GroupGroupoid( C33 ); 
groupoid with 2 pieces:
1:  single piece groupoid with rays: < Group( [ ()>-(4,5,6)(7,9,8)->() ] ), 
[ (), (11,12,13), (11,13,12) ], [ ()>-()->(), ()>-(7,8,9)->(11,12,13), 
  ()>-(7,9,8)->(11,13,12) ] >
2:  single piece groupoid with rays: < Group( 
[ (12,13)>-(2,3)(4,6)(7,8)->(12,13) ] ), [ (12,13), (11,12), (11,13) ], 
[ (12,13)>-(2,3)(5,6)(8,9)->(12,13), (12,13)>-(2,3)(5,6)(7,9)->(11,13), 
  (12,13)>-(2,3)(5,6)(7,8)->(11,12) ] >
]]>
</Example>

<ManSection>
   <Oper Name="GroupGroupoidElement" 
         Arg="precat1 root g" /> 
<Description>
Since we need to define a second multiplication on the elements of <M>G</M>, 
we have to convert <M>g \in G</M> into a new type of object, 
<C>GroupGroupoidElementType</C>, a record <M>e</M> with fields: 
<List>
<Item>
<C>e!.precat1</C>, the precat<M>^1</M>-group from which <M>\calG</M> was formed; 
</Item>
<Item>
<C>e!.root</C>, the root object of the component containing <M>e</M>; 
</Item>
<Item>
<C>e!.element</C>, the element <M>g \in G</M>; 
</Item>
<Item>
<C>e!.tail</C>, the tail object of the element <M>e</M>; 
</Item>
<Item>
<C>e!.head</C>, the head object of the element <M>e</M>; 
</Item>
<Item>
<C>e!.tailid</C>, the identity element at the tail object; 
</Item>
<Item>
<C>e!.headid</C>, the identity element at the head object; 
</Item>
</List>
In the example we pick a particular pair of elements <M>g_1,g_2 \in G</M>, 
construct group groupoid elements <M>e_1,e_2</M> from them, 
and show that <M>g_1*g_2</M> and <M>e_1*e_2</M> give very different results. 
(Warning: at present iterators for object groups and homsets do not work.)
</Description>
</ManSection>
<P/>
<Example>
<![CDATA[
gap> piece2 := Pieces( gpd33 )[2];;
gap> obs2 := piece2!.objects; 
[ (12,13), (11,12), (11,13) ]
gap> RaysOfGroupoid( piece2 );
[ (12,13)>-(2,3)(5,6)(8,9)->(12,13), (12,13)>-(2,3)(5,6)(7,9)->(11,13), 
  (12,13)>-(2,3)(5,6)(7,8)->(11,12) ]
gap> g1 := (1,2)(5,6)(7,9);; 
gap> g2 := (2,3)(4,5)(7,8);;                         
gap> g1 * g2;
(1,3,2)(4,5,6)(7,9,8)
gap> e1 := GroupGroupoidElement( C33, (12,13), g1 ); 
(11,12)>-(1,2)(5,6)(7,9)->(12,13)
gap> e2 := GroupGroupoidElement( C33, (12,13), g2 );
(12,13)>-(2,3)(4,5)(7,8)->(11,13)
gap> e1*e2;
(11,12)>-(1,2)(4,5)(8,9)->(11,13)
gap> e2^-1;
(11,13)>-(1,3)(4,6)(7,9)->(12,13)
gap> obgp := ObjectGroup( gpd33, (11,12) );;
gap> GeneratorsOfGroup( obgp )[1];
(11,13)>-( 1, 3)( 4, 6)( 7, 8)->(11,13)
gap> Homset( gpd33, (11,12), (11,13) );
<homset (11,12) -> (11,13) with head group Group( 
[ (11,12)>-( 1, 2)( 4, 6)( 7, 8)->(11,12) ] )>
]]>
</Example>

</Section>

</Chapter>
