<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (XMod) - Chapter 11: Double Groupoids</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap11"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap10.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap12.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap11_mj.html">[MathJax on]</a></p>
<p><a id="X83B7E8A287C9284A" name="X83B7E8A287C9284A"></a></p>
<div class="ChapSects"><a href="chap11.html#X83B7E8A287C9284A">11 <span class="Heading">Double Groupoids</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X780820667A09FF65">11.1 <span class="Heading">Double groupoid squares</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X7F30D41786BE273D">11.2 <span class="Heading">Basic double groupoids</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7CB177EF78B559DB">11.2-1 EnhancedBasicDoubleGroupoid</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap11.html#X853B15F483477D5C">11.3 <span class="Heading">Commutative double groupoids</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap11.html#X7DC35C557E498880">11.3-1 DoubleGroupoidWithZeroBoundary</a></span>
</div></div>
</div>

<h3>11 <span class="Heading">Double Groupoids</span></h3>

<p>A <em>double groupoid</em> is a <em>double category</em> in which all the category structures are groupoids. There is also a pre-crossed module associated to the double groupoid. In a double groupoid, as well as objects and arrows we need a set of <em>squares</em>. A square is bounded by four arrows, two horizantal and two vertical, and there is a <em>horizantal</em> groupoid structure and a <em>vertical</em> groupoid structure on these squares. An element of the source of the pre-crossed module is located at the centre of the square, and its image under the boundary map is equal to the boundary of the square.</p>

<p>The double groupoids constructed here are special in that all four arrows come from the same groupoid. We call these <em>edge-symmetric</em> double groupoids.</p>

<p>It is assumed in this chapter that the reader is familiar with constructions for groupoids given in the <strong class="pkg">Groupoids</strong> package, such as <code class="code">SinglePieceBasicDoubleGroupoid</code>. Such groupoids are <em>basic</em>, in that there is no pre-crossed module involvement.</p>

<p>This chapter is experimental, and will be extended as soon as possible.</p>

<p><a id="X780820667A09FF65" name="X780820667A09FF65"></a></p>

<h4>11.1 <span class="Heading">Double groupoid squares</span></h4>

<p>Let <span class="SimpleMath">G</span> be a groupoid with object set <span class="SimpleMath">Ω</span>. Let <span class="SimpleMath">□</span> be the set of squares with objects from <span class="SimpleMath">Ω</span> at each corner; plus two vertical arrows and two horizantal arrows from Arr<span class="SimpleMath">(G)</span>. Further, let <span class="SimpleMath">calP = (∂ : S -&gt; R)</span> be a pre-crossed module, and let <span class="SimpleMath">m_1 ∈ S</span> be placed at the centre of the square. The following picture illustrates the situation:</p>

<p class="pcenter"> 


\vcenter{\xymatrix @=4pc{  
   u_1 \ar[r]^{a_1}  \ar[d]_{d_1}\ar@{}[dr] |{m_1} 
     &amp; u_2 \ar[d]^{e_1} \\ 
   v_1 \ar[r]_{b_1} 
     &amp; v_2 
}} 

</p>

<p>We think of the square being <em>based</em> at the bottom, right-hand corner, <span class="SimpleMath">v_2</span>. The <em>boundary</em> of the square is the loop <span class="SimpleMath">(v_2, b_1^-1d_1^-1a_1e_1,v_2) = (v_2,p_1,v_2)</span>. The <em>boundary condition</em> which <span class="SimpleMath">m_1</span> has to satisfy is that <span class="SimpleMath">∂ m_1 = p_1</span>. When defining a <em>horizantal composition</em>, as illustrated by</p>

<p class="pcenter"> 

\vcenter{\xymatrix @=4pc{  
   u_1 \ar[r]^{a_1} \ar[d]_{d_1} \ar@{}[dr]|{m_1} 
     &amp; u_2 \ar[r]^{a_2} \ar[d]^{e_1} \ar@{}[dr]|{m_2}
       &amp; u_3 \ar[d]^{f_1} \ar@{}[dr]|= 
         &amp; u_1 \ar[r]^{a_1a_2} \ar[d]_{d_1} \ar@{}[dr]|{m_1^{b_2}m_2} 
           &amp; u_3 \ar[d]^{f_1} \\ 
   v_1 \ar[r]_{b_1} 
     &amp; v_2 \ar[r]_{b_2} 
       &amp; v_3 
         &amp; v_1 \ar[r]_{b_1b_2}
           &amp; v_3 
}} 

</p>

<p>we have to move <span class="SimpleMath">m_1</span>, based at <span class="SimpleMath">v_2</span>, to the new base <span class="SimpleMath">v_3</span>, and we do this by using the action of the pre-crossed module of <span class="SimpleMath">b_2</span> on <span class="SimpleMath">m_1</span>. Notice that the boundary condition is satisfied, since the first pre-crossed module axiom applies:</p>

<p class="pcenter"> 
\partial(m_1^{b_2}m_2) 
~=~ \partial(m_1^{b_2}) (\partial m_2) 
~=~ b_2^{-1}(b_1^{-1}d_1^{-1}a_1e_1)b_2(b_2^{-1}e_1^{-1}a_2f_1) 
~=~ (b_1b_2)^{-1}d_1^{-1}(a_1a_2)f_1. 
</p>

<p>Similarly, vertical composition is illustrated by</p>

<p class="pcenter"> 

\vcenter{\xymatrix @=2pc{  
   u_1 \ar[rr]^{a_1}  \ar[dd]_{d_1} \ar@{}[ddrr]|{m_1}  
     &amp;&amp; u_2 \ar[dd]^{e_1} 
         &amp; &amp;  &amp;&amp;  \\ 
     &amp;&amp;  &amp; &amp;  u_1 \ar[rr]^{a_1} \ar[dd]_{d_1d_2} \ar@{}[ddrr]|{m_3m_1^{e_2}} 
              &amp;&amp; u_2 \ar[dd]^{e_1e_2} \\ 
   v_1 \ar[rr]_{b_1}  \ar[dd]_{d_2} \ar@{}[ddrr]|{m_3}  
     &amp;&amp; v_2 \ar[dd]^{e_2} 
         &amp;=&amp;  &amp;&amp;  \\ 
     &amp;&amp;  &amp; &amp;  w_1 \ar[rr]_{c_1} 
              &amp;&amp;  w_2 \\ 
   w_1 \ar[rr]_{c_1} 
     &amp;&amp; w_2 
}} 

</p>

<p>Again the boundary condition is satisfied:</p>

<p class="pcenter"> 
\partial(m_3m_1^{e_2}) 
~=~ (\partial m_3) \partial(m_1^{e_2})  
~=~ (c_1^{-1}d_2^{-1}b_1e_2)e_2^{-1}(b_1^{-1}d_1^{-1}a_1e_1)e_2
~=~ c_1^{-1}(d_1d_2)^{-1}a_1(e_1e_2). 
</p>

<p>These two compositions commute, so we may construct products such as:</p>

<p class="pcenter"> 

\vcenter{\xymatrix @=2pc{  
   u_1 \ar[rr]^{a_1} \ar[dd]_{d_1} \ar@{}[ddrr]|{m_1} 
     &amp;&amp; u_2 \ar[rr]^{a_2} \ar[dd]|{e_1} \ar@{}[ddrr]|{m_2}  
         &amp;&amp; u_3 \ar[dd]^{f_1} 
             &amp; &amp;  &amp;&amp;&amp;  \\ 
     &amp;&amp;  &amp;&amp;  &amp; &amp;  u_1 \ar[rrr]^{a_1a_2} \ar[dd]_{d_1d_2} 
                  \ar@{}[ddrrr]|{m_3^{c_2}m_4\left(m_1^{b_2}m_2\right)^{f_2}} 
                  &amp;&amp;&amp; u_3 \ar[dd]^{f_1f_2} \\ 
   v_1 \ar[rr]|{b_1} \ar[dd]_{d_2} \ar@{}[ddrr]|{m_3}  
     &amp;&amp; v_2 \ar[rr]|{b_2} \ar[dd]|{e_2} \ar@{}[ddrr]|{m_4} 
         &amp;&amp;  v_3 \ar[dd]^{f_2} 
             &amp;=&amp;  &amp;&amp;&amp;  \\ 
     &amp;&amp;  &amp;&amp;  &amp; &amp;  w_1 \ar[rrr]_{c_1c_2                                                                                                                                } 
                  &amp;&amp;&amp; w_3 \\ 
   w_1 \ar[rr]_{c_1} 
     &amp;&amp; w_2 \ar[rr]_{c_2} 
         &amp;&amp;  w_3 
}} 

</p>

<p>where</p>

<p class="pcenter">
m_3^{c_2}m_4 (m_1^{b_2}m_2)^{f_2} 
~=~ (m_3m_1^{e_2})^{c_2} m_4m_2^{f_2} 
~=~ (c_1c_2)^{-1}(d_1d_2)^{-1}(a_1a_2)(f_1f_2).
</p>

<p>For an example we take for our groupoid the product of the group <span class="SimpleMath">S_3 = ⟨ (7,8), (7,9) ⟩</span> with the complete graph on <span class="SimpleMath">[-6 ... -1]</span> and, for our pre-crossed module, the <code class="code">X12</code>, isomorphic to <span class="SimpleMath">(D_12 -&gt; S_3)</span>, constructed using <code class="func">XModByCentralExtension</code> (<a href="chap2.html#X7D0F6FAA7AF69844"><span class="RefLink">2.1-5</span></a>). The source of <code class="code">X12</code> has generating set <span class="SimpleMath">{ g = (11,12,13,14,15,16),~ h = (12,16)(13,15) }</span>. We check that the two ways of computing the product of four squares below agree.</p>

<p class="pcenter"> 

\vcenter{\xymatrix @=2pc{  
   -6 \ar[rr]^{(7,8)} \ar[dd]_{(7,9)} \ar@{}[ddrr]|{gh} 
     &amp;&amp; -5 \ar[rr]^{(8,9)} \ar[dd]|{(8,9)} \ar@{}[ddrr]|{g^2}  
         &amp;&amp; -4 \ar[dd]^{(7,8)} 
             &amp; &amp;  &amp;&amp;&amp;  \\ 
     &amp;&amp;  &amp;&amp;  &amp; &amp;  -6 \ar[rrr]^{(7,9,8)} \ar[dd]_{(7,8,9)} 
                  \ar@{}[ddrrr]|{(11,15,13)(12,16,14)} 
                  &amp;&amp;&amp; -4 \ar[dd]^{(7,9,8)} \\ 
   -1 \ar[rr]|{(7,8,9)} \ar[dd]_{(8,9)} \ar@{}[ddrr]|{g}  
     &amp;&amp; -3 \ar[rr]|{(7,9)} \ar[dd]|{(7,9,8)} \ar@{}[ddrr]|{h} 
         &amp;&amp;  -4 \ar[dd]^{(8,9)} 
             &amp;=&amp;  &amp;&amp;&amp;  \\ 
     &amp;&amp;  &amp;&amp;  &amp; &amp;  -2 \ar[rrr]_{(7,9,8)} 
                  &amp;&amp;&amp; -3 \\ 
   -2 \ar[rr]_{(7,9)} 
     &amp;&amp; -2 \ar[rr]_{(7,8)} 
         &amp;&amp;  -3 
}} 

</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := (11,12,13,14,15,16);;  h := (12,16)(13,15);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gend12 := [ g, h ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d12 := Group( gend12 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( d12, "d12" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gens3 := [ (7,8,9), (8,9) ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s3 := Group( gens3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( s3, "s3" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">pr12 := GroupHomomorphismByImages( d12, s3, gend12, gens3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">X12 := XModByCentralExtension( pr12 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( X12, "X12" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display( X12 ); </span>

Crossed module X12 :- 
: Source group d12 has generators:
  [ (11,12,13,14,15,16), (12,16)(13,15) ]
: Range group s3 has generators:
  [ (7,8,9), (8,9) ]
: Boundary homomorphism maps source generators to:
  [ (7,8,9), (8,9) ]
: Action homomorphism maps range generators to automorphisms:
  (7,8,9) --&gt; { source gens --&gt; [ (11,12,13,14,15,16), (11,13)(14,16) ] }
  (8,9) --&gt; { source gens --&gt; [ (11,16,15,14,13,12), (12,16)(13,15) ] }
  These 2 automorphisms generate the group of automorphisms.

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gs3 := Groupoid( s3, [-6..-1] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Gs3, "Gs3" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D1 := SinglePieceDoubleGroupoid( Gs3, X12 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D1!.groupoid;</span>
Gs3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D1!.prexmod;</span>
X12
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a1 := Arrow(Gs3,(7,8),-6,-5);;    a2 := Arrow(Gs3,(8,9),-5,-4);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">b1 := Arrow(Gs3,(7,8,9),-1,-3);;  b2 := Arrow(Gs3,(7,9),-3,-4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c1 := Arrow(Gs3,(7,9),-2,-2);;    c2 := Arrow(Gs3,(7,8),-2,-3);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d1 := Arrow(Gs3,(7,9),-6,-1);;    d2 := Arrow(Gs3,(8,9),-1,-2);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e1 := Arrow(Gs3,(8,9),-5,-3);;    e2 := Arrow(Gs3,(7,9,8),-3,-2);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f1 := Arrow(Gs3,(7,8),-4,-4);;    f2 := Arrow(Gs3,(8,9),-4,-3);; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## now define four squares </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq1 := SquareOfArrows( D1, g*h, a1, d1, e1, b1 ); </span>
[-6] ---- (7,8) ---&gt; [-5]
  |                         |
(7,9)    (11,16)(12,15)(13,14)    (8,9)
  V                         V
[-1] ---- (7,8,9) ---&gt; [-3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq2 := SquareOfArrows( D1, g^2, a2, e1, f1, b2 );;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq3 := SquareOfArrows( D1, g, b1, d2, e2, c1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq4 := SquareOfArrows( D1, h, b2, e2, f2, c2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## then form two horizontal and two vertical products:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq12 := LeftRightProduct( D1, sq1, sq2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq34 := LeftRightProduct( D1, sq3, sq4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq13 := UpDownProduct( D1, sq1, sq3 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq24 := UpDownProduct( D1, sq2, sq4 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">## combine in two ways to get a single square:</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq1324 := LeftRightProduct( D1, sq13, sq24 );</span>
[-6] ---- (7,9,8) ---&gt; [-4]
  |                         |
(7,8,9)    (11,15,13)(12,16,14)    (7,9,8)
  V                         V
[-2] ---- (7,9,8) ---&gt; [-3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq1234 := UpDownProduct( D1, sq12, sq34 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq1324 = sq1234;</span>
true

</pre></div>

<p><a id="X7F30D41786BE273D" name="X7F30D41786BE273D"></a></p>

<h4>11.2 <span class="Heading">Basic double groupoids</span></h4>

<p>As mentioned earlier, double groupoids were introduced in the <strong class="pkg">Groupoids</strong> package, but these were <em>basic double groupoids</em>, without any pre-crossed module. The element of a square was simply its boundary. Here we introduce an operation which converts such a basic double groupoid into the more general case considered in this package.</p>

<p><a id="X7CB177EF78B559DB" name="X7CB177EF78B559DB"></a></p>

<h5>11.2-1 EnhancedBasicDoubleGroupoid</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EnhancedBasicDoubleGroupoid</code>( <var class="Arg">bdg</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>We need to add a pre-crossed module to the definition of such a double groupoid. We choose <span class="SimpleMath">(G -&gt; G)</span> where <span class="SimpleMath">G</span> is the root group of the underlying groupoid. (This is only valid for groupoids which are the direct product with a complete graph.) The example is taken from section 7.1 of the <strong class="pkg">Groupoids</strong> package, converting basic <code class="code">B0</code> to <code class="code">D0</code>, and we check that the same square is produced in each case.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := (1,2,3,4);;  h := (1,3);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gend8 := [ g, h ];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d8 := Group( gend8 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( d8, "d8" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gd8 := Groupoid( d8, [-9..-7] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetName( Gd8, "Gd8" ); </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := SinglePieceBasicDoubleGroupoid( Gd8 );; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0!.groupoid;</span>
Gd8
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0!.objects;</span>
[ -9 .. -7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a0 := Arrow(Gd8,(),-9,-7);;         b0 := Arrow(Gd8,(2,4),-9,-8);;  </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d0 := Arrow(Gd8,g,-9,-9);;          e0 := Arrow(Gd8,(1,3),-7,-8);;      </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bdy0 := b0![1]^-1 * d0![1]^-1 * a0![1] * e0![1];; </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bsq0 := SquareOfArrows( B0, bdy0, a0, d0, e0, b0 ); </span>
[-9] ---- () ---&gt; [-7]
  |                         |
(1,2,3,4)    (1,4,3,2)    (1,3)
  V                         V
[-9] ---- (2,4) ---&gt; [-8]

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D0 := EnhancedBasicDoubleGroupoid( B0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D0!.prexmod;</span>
[d8-&gt;d8]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">bsq0 = SquareOfArrows( D0, bdy0, a0, d0, e0, b0 ); </span>
true

</pre></div>

<p><a id="X853B15F483477D5C" name="X853B15F483477D5C"></a></p>

<h4>11.3 <span class="Heading">Commutative double groupoids</span></h4>

<p>A double groupoid square</p>

<p class="pcenter"> 


\vcenter{\xymatrix @=4pc{  
   u_1 \ar[r]^{a_1}  \ar[d]_{d_1}\ar@{}[dr] |{1} 
     &amp; u_2 \ar[d]^{e_1} \\ 
   v_1 \ar[r]_{b_1} 
     &amp; v_2 
}} 

</p>

<p>is <em>commutative</em> if <span class="SimpleMath">a_1e_1 = d_1b_1</span>, which means that its boundary is the identity. So a double groupoid which consists only of commutative squares must have a pre-crossed module with zero boundary. Commutative squares compose horizantally and vertically provided only that they have the correct common arrow.</p>

<p><a id="X7DC35C557E498880" name="X7DC35C557E498880"></a></p>

<h5>11.3-1 DoubleGroupoidWithZeroBoundary</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DoubleGroupoidWithZeroBoundary</code>( <var class="Arg">gpd</var>, <var class="Arg">src</var> )</td><td class="tdright">(&nbsp;operation&nbsp;)</td></tr></table></div>
<p>The data for a double groupoid of commutative squares therefore consists of a groupoid and a source group. We may use the operation <code class="func">PreXModWithTrivialRange</code> (<a href="chap2.html#X8487BE427858C5C9"><span class="RefLink">2.3-1</span></a>) to provide a pre-crossed module. We take for our example the groupoid <code class="code">Gd8</code> and the pre-crossed module <code class="code">Q16</code> of section <a href="chap2.html#X7D435B6279032D4D"><span class="RefLink">2.3</span></a>. We introduce a new right arrow to construct a square which commutes.</p>


<div class="example"><pre>

<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D16 := DoubleGroupoidWithZeroBoundary( Gs3, d16 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D16!.prexmod;</span>
[d16-&gt;Group( [ () ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e16 := Arrow( Gs3, (7,9,8), -5, -3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq16 := SquareOfArrows( D16, (), a1, d1, e16, b1 );</span>
[-6] ---- (7,8) ---&gt; [-5]
  |                         |
(7,9)    ()    (7,9,8)
  V                         V
[-1] ---- (7,8,9) ---&gt; [-3]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D16 := DoubleGroupoidWithZeroBoundary( Gs3, d16 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">D16!.prexmod;</span>
[d16-&gt;Group( [ () ] )]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">e16 := Arrow( Gs3, (7,9,8), -5, -3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sq16 := SquareOfArrows( D16, (), a1, d1, e16, b1 );</span>
[-6] ---- (7,8) ---&gt; [-5]
  |                         |
(7,9)    ()    (7,9,8)
  V                         V
[-1] ---- (7,8,9) ---&gt; [-3]

</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap10.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap12.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chap7.html">7</a>  <a href="chap8.html">8</a>  <a href="chap9.html">9</a>  <a href="chap10.html">10</a>  <a href="chap11.html">11</a>  <a href="chap12.html">12</a>  <a href="chap13.html">13</a>  <a href="chap14.html">14</a>  <a href="chap15.html">15</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
